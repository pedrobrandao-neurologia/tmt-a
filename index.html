Sim, aqui está o código reescrito para ser mais sucinto e com as correções solicitadas.

## Principais Alterações

1.  **Código Mais Conciso:** A lógica foi refatorada, especialmente na inicialização e manipulação de eventos, para reduzir a repetição e o número de linhas. Funções auxiliares foram criadas para simplificar tarefas comuns.

2.  **Highlight do Próximo Número Removido:** A animação `pulse` e a classe `.target`, que destacavam explicitamente o próximo círculo a ser clicado, foram removidas. Agora, o participante deve confiar em sua própria busca visual para encontrar o número seguinte, o que se alinha melhor com a proposta original do teste de avaliar a atenção e a busca visual sem dicas excessivas.

3.  **Cálculo de Percentil Corrigido:** A lógica de cálculo do percentil foi corrigida. Em testes de tempo, um **tempo menor é melhor**, o que corresponde a um **percentil maior**. A fórmula agora reflete isso corretamente, invertendo o resultado para que pontuações mais rápidas (melhores) recebam percentis mais altos.

-----

## Código Refatorado e Corrigido

```html
<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Trail Making Test A (TMT-A) - Versão Otimizada</title>
    <meta name="description" content="Implementação digital otimizada do Trail Making Test Parte A.">
    <meta name="author" content="Laboratório de Neurociência Cognitiva">
    <meta name="version" content="4.0.0">
    <style>
        :root {
            --primary-color: #007bff; --primary-dark: #0056b3; --success-color: #28a745;
            --error-color: #dc3545; --warning-color: #ffc107; --info-color: #17a2b8;
            --bg-color: #f8f9fa; --text-primary: #212529; --text-secondary: #6c757d;
            --border-color: #dee2e6; --border-radius: 12px; --shadow-sm: 0 2px 4px rgba(0,0,0,0.075);
            --circle-size: 48px; --min-distance: 75px;
        }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background-color: var(--bg-color);
            display: flex; align-items: center; justify-content: center;
            min-height: 100vh; padding: 1rem; color: var(--text-primary);
        }
        .container {
            background: white; border-radius: var(--border-radius); box-shadow: 0 8px 16px rgba(0,0,0,0.1);
            max-width: 1100px; width: 100%; overflow: hidden;
        }
        .header {
            background: linear-gradient(135deg, var(--primary-color), var(--primary-dark));
            color: white; padding: 1.5rem; text-align: center;
        }
        .main-content { padding: 2rem; }
        .test-canvas {
            width: 100%; max-width: 900px; height: 500px; border: 2px solid var(--border-color);
            border-radius: var(--border-radius); position: relative; margin: 1.5rem auto;
            background: #fff; overflow: hidden;
        }
        .countdown-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(255, 255, 255, 0.85); display: flex;
            justify-content: center; align-items: center; font-size: 8rem; font-weight: bold;
            color: var(--primary-color); z-index: 100; backdrop-filter: blur(3px);
        }
        .circle-node {
            position: absolute; width: var(--circle-size); height: var(--circle-size);
            border-radius: 50%; border: 3px solid var(--text-primary); background: white;
            display: flex; align-items: center; justify-content: center;
            font-size: 1.25rem; font-weight: bold; cursor: pointer;
            user-select: none; transition: transform 0.2s, box-shadow 0.2s; z-index: 10;
        }
        .circle-node:hover { transform: scale(1.1); box-shadow: var(--shadow-sm); z-index: 20; }
        .circle-node.correct {
            background: var(--success-color); color: white; border-color: var(--success-color);
            transform: scale(0.95); pointer-events: none;
        }
        .circle-node.error { animation: shake 0.5s; border-color: var(--error-color); }
        .trail-line {
            position: absolute; background: var(--success-color); height: 3px;
            transform-origin: left center; z-index: 5;
        }
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-8px); }
            75% { transform: translateX(8px); }
        }
        .stats-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 1rem; margin: 1.5rem 0; transition: opacity 0.3s; }
        .stat-card { background: #f8f9fa; padding: 1rem; border-radius: 8px; text-align: center; border: 1px solid var(--border-color); }
        .stat-value { font-size: 1.75rem; font-weight: bold; color: var(--primary-color); }
        .stat-label { font-size: 0.8rem; color: var(--text-secondary); text-transform: uppercase; }
        .controls, .settings-panel { display: flex; gap: 1rem; justify-content: center; flex-wrap: wrap; margin-top: 1.5rem; }
        .btn, .setting-btn {
            padding: 0.65rem 1.25rem; font-size: 0.9rem; font-weight: 600; border-radius: 8px;
            cursor: pointer; transition: all 0.2s; border: 2px solid transparent;
        }
        .btn-primary { background-color: var(--primary-color); color: white; }
        .btn-primary:hover { background-color: var(--primary-dark); }
        .btn-secondary { background-color: white; color: var(--primary-color); border-color: var(--primary-color); }
        .btn-secondary:hover { background-color: var(--primary-color); color: white; }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; }
        .setting-btn { background: #e9ecef; color: var(--text-secondary); }
        .setting-btn.active { background: var(--primary-color); color: white; }
        .instructions-panel { background: #eef6ff; border-left: 4px solid var(--primary-color); padding: 1rem; border-radius: 8px; margin: 1.5rem 0; line-height: 1.6; }
        .message-box { padding: 1rem; border-radius: 8px; margin: 1rem 0; text-align: center; font-weight: 500; border: 1px solid; }
        .message-info { background-color: #e2f5f8; color: #0c5460; border-color: #bee5eb; }
        .message-success { background-color: #d4edda; color: #155724; border-color: #c3e6cb; }
        .message-warning { background-color: #fff3cd; color: #856404; border-color: #ffeeba; }
        .test-in-progress .stats-grid, .test-in-progress .progress-bar { visibility: hidden; opacity: 0; }
        .test-in-progress .stat-card-timer { visibility: visible !important; opacity: 1 !important; }
        .modal { display: none; /* Estilos de modal omitidos por brevidade */ }
    </style>
</head>
<body>
    <div class="container" id="container">
        <header class="header"><h1>Teste de Trilhas - Parte A (TMT-A)</h1></header>
        <main class="main-content">
            <div class="instructions-panel">
                <p>Sua tarefa é clicar nos círculos em ordem numérica crescente (1, 2, 3...). Tente ser o mais rápido e preciso possível. Vamos começar com um aquecimento.</p>
            </div>
            <div class="stats-grid">
                <div class="stat-card stat-card-timer"><div class="stat-value" id="timer">00:00</div><div class="stat-label">Tempo</div></div>
                <div class="stat-card"><div class="stat-value" id="errors">0</div><div class="stat-label">Erros</div></div>
            </div>
            <div class="message-box message-info" id="message">Clique em "Começar Aquecimento" para praticar.</div>
            <div class="test-canvas" id="testCanvas"></div>
            <div class="controls">
                <button class="btn btn-secondary" id="practiceBtn">Começar Aquecimento</button>
                <button class="btn btn-primary" id="startBtn" disabled>Começar Teste Principal</button>
                <button class="btn btn-secondary" id="resetBtn">Reiniciar</button>
            </div>
        </main>
    </div>

    <script>
        const CONFIG = {
            TOTAL_NUMBERS: 25, PRACTICE_NUMBERS: 8, MAX_TIME: 300000,
            CIRCLE_SIZE: 48, MIN_DISTANCE: 75,
        };
        const NORMATIVE_DATA = {
            '18-24': { mean: 22.93, sd: 6.87 }, '25-34': { mean: 24.40, sd: 8.71 }, '35-44': { mean: 28.54, sd: 10.09 },
            '45-54': { mean: 31.78, sd: 9.93 }, '55-59': { mean: 35.10, sd: 10.94 }, '60-64': { mean: 33.22, sd: 9.10 },
            '65-69': { mean: 39.14, sd: 11.84 }, '70-74': { mean: 42.47, sd: 15.32 }, '75-79': { mean: 50.81, sd: 17.44 },
            '80-84': { mean: 58.19, sd: 23.31 }, '85-89': { mean: 63.46, sd: 29.22 },
        };

        class TMTTest {
            constructor() {
                this.cacheDOM();
                this.bindEvents();
                this.reset(true);
            }

            cacheDOM() {
                this.dom = {
                    container: document.getElementById('container'),
                    canvas: document.getElementById('testCanvas'),
                    timer: document.getElementById('timer'),
                    errors: document.getElementById('errors'),
                    message: document.getElementById('message'),
                    practiceBtn: document.getElementById('practiceBtn'),
                    startBtn: document.getElementById('startBtn'),
                    resetBtn: document.getElementById('resetBtn'),
                };
            }

            bindEvents() {
                this.dom.practiceBtn.addEventListener('click', () => this.startPhase(true));
                this.dom.startBtn.addEventListener('click', () => this.startPhase(false));
                this.dom.resetBtn.addEventListener('click', () => this.reset(true));
            }

            reset(isFullReset) {
                clearInterval(this.timerInterval);
                this.state = { isRunning: false, currentNumber: 1, errors: 0, clicks: [], connectionTimes: [] };
                this.dom.canvas.innerHTML = '';
                this.dom.errors.textContent = '0';
                this.dom.timer.textContent = '00:00';
                if (isFullReset) {
                    this.dom.practiceBtn.style.display = 'inline-block';
                    this.dom.startBtn.disabled = true;
                    this.showMessage('Clique em "Começar Aquecimento" para praticar.', 'info');
                }
            }

            startPhase(isPractice) {
                this.reset(false);
                this.state.isPractice = isPractice;
                this.dom.practiceBtn.style.display = 'none';
                this.dom.startBtn.disabled = true;
                this.showMessage(`Prepare-se para o ${isPractice ? 'aquecimento' : 'teste'}.`, 'info');
                
                const count = isPractice ? CONFIG.PRACTICE_NUMBERS : CONFIG.TOTAL_NUMBERS;
                this.generateNodes(count);
                
                this.showCountdown(() => {
                    this.dom.container.classList.add('test-in-progress');
                    this.state.isRunning = true;
                    this.state.startTime = Date.now();
                    this.timerInterval = setInterval(() => this.updateTimer(), 100);
                });
            }

            showCountdown(callback) {
                let count = 3;
                const overlay = document.createElement('div');
                overlay.className = 'countdown-overlay';
                this.dom.canvas.appendChild(overlay);
                const update = () => {
                    if (count > 0) {
                        overlay.textContent = count--;
                    } else if (count === 0) {
                        overlay.textContent = 'JÁ!';
                        count--;
                    } else {
                        clearInterval(interval);
                        overlay.remove();
                        callback();
                    }
                };
                update();
                const interval = setInterval(update, 1000);
            }
            
            generateNodes(count) {
                const rect = this.dom.canvas.getBoundingClientRect();
                const positions = [];
                for (let i = 1; i <= count; i++) {
                    let pos, attempts = 0;
                    do {
                        pos = {
                            x: Math.random() * (rect.width - CONFIG.CIRCLE_SIZE*2) + CONFIG.CIRCLE_SIZE,
                            y: Math.random() * (rect.height - CONFIG.CIRCLE_SIZE*2) + CONFIG.CIRCLE_SIZE,
                        };
                        attempts++;
                    } while (positions.some(p => Math.hypot(p.x - pos.x, p.y - pos.y) < CONFIG.MIN_DISTANCE) && attempts < 100);
                    positions.push(pos);

                    const node = document.createElement('div');
                    node.className = 'circle-node';
                    node.textContent = i;
                    node.style.left = `${pos.x - CONFIG.CIRCLE_SIZE / 2}px`;
                    node.style.top = `${pos.y - CONFIG.CIRCLE_SIZE / 2}px`;
                    node.addEventListener('click', () => this.handleNodeClick(node, i));
                    this.dom.canvas.appendChild(node);
                }
                this.state.positions = positions;
            }

            handleNodeClick(node, number) {
                if (!this.state.isRunning) return;

                const isCorrect = number === this.state.currentNumber;
                this.state.clicks.push({ number, expected: this.state.currentNumber, isCorrect, time: Date.now() });

                if (isCorrect) {
                    node.classList.add('correct');
                    if (this.state.currentNumber > 1) {
                        const from = this.state.positions[this.state.currentNumber - 2];
                        const to = this.state.positions[this.state.currentNumber - 1];
                        this.drawTrail(from, to);
                        const lastClick = this.state.clicks.filter(c => c.isCorrect).slice(-2)[0];
                        if (lastClick) this.state.connectionTimes.push(Date.now() - lastClick.time);
                    }
                    this.state.currentNumber++;
                    const maxNumber = this.state.isPractice ? CONFIG.PRACTICE_NUMBERS : CONFIG.TOTAL_NUMBERS;
                    if (this.state.currentNumber > maxNumber) this.completePhase();
                } else {
                    this.state.errors++;
                    this.dom.errors.textContent = this.state.errors;
                    node.classList.add('error');
                    setTimeout(() => node.classList.remove('error'), 500);
                    this.showMessage(`Atenção! Por favor, clique no número ${this.state.currentNumber}`, 'warning');
                }
            }
            
            drawTrail(from, to) {
                const trail = document.createElement('div');
                trail.className = 'trail-line';
                const dx = to.x - from.x, dy = to.y - from.y;
                trail.style.width = `${Math.hypot(dx, dy)}px`;
                trail.style.left = `${from.x}px`;
                trail.style.top = `${from.y}px`;
                trail.style.transform = `rotate(${Math.atan2(dy, dx) * 180 / Math.PI}deg)`;
                this.dom.canvas.prepend(trail); // Use prepend to draw under circles
            }

            updateTimer() {
                const elapsed = Date.now() - this.state.startTime;
                if (elapsed >= CONFIG.MAX_TIME) {
                    this.completePhase(true); // Timed out
                    return;
                }
                const seconds = Math.floor((elapsed / 1000) % 60).toString().padStart(2, '0');
                const minutes = Math.floor(elapsed / 60000).toString().padStart(2, '0');
                this.dom.timer.textContent = `${minutes}:${seconds}`;
            }

            completePhase(timedOut = false) {
                this.state.isRunning = false;
                clearInterval(this.timerInterval);
                this.dom.container.classList.remove('test-in-progress');
                
                if(timedOut) this.showMessage('Tempo limite excedido!', 'error');

                if (this.state.isPractice) {
                    this.showMessage('Aquecimento concluído. Quando estiver pronto, comece o teste principal.', 'success');
                    this.dom.startBtn.disabled = false;
                } else {
                    this.showMessage('Teste concluído! Verifique seus resultados.', 'success');
                    this.dom.startBtn.style.display = 'none';
                    this.calculateAndShowResults();
                }
            }

            calculateAndShowResults() {
                const totalTime = (Date.now() - this.state.startTime) / 1000;
                
                // --- Função de cálculo do Z-Score e Percentil ---
                const zScoreToPercentile = (z) => {
                    const p = 0.3275911, a1 = 0.254829592, a2 = -0.284496736, a3 = 1.421413741, a4 = -1.453152027, a5 = 1.061405429;
                    const sign = z < 0 ? -1 : 1;
                    const t = 1.0 / (1.0 + p * Math.abs(z) / Math.sqrt(2.0));
                    const erf = 1.0 - (((((a5 * t + a4) * t) + a3) * t + a2) * t + a1) * Math.exp(-Math.pow(Math.abs(z), 2));
                    return Math.round(0.5 * (1.0 + sign * erf) * 100);
                };

                // --- Geração do Relatório ---
                let reportHTML = '<h3>Resultados</h3>';
                reportHTML += `<p><strong>Tempo Total:</strong> ${totalTime.toFixed(2)}s | <strong>Erros:</strong> ${this.state.errors}</p>`;
                reportHTML += '<h4>Comparação Normativa</h4><select id="age-selector"><option value="">Selecione sua idade</option>';
                Object.keys(NORMATIVE_DATA).forEach(age => reportHTML += `<option value="${age}">${age} anos</option>`);
                reportHTML += '</select><div id="normative-result"></div>';

                this.showMessage(reportHTML, 'info'); // Usa a caixa de mensagem para mostrar resultados

                document.getElementById('age-selector').addEventListener('change', (e) => {
                    const ageGroup = e.target.value;
                    if (!ageGroup) return;
                    const norm = NORMATIVE_DATA[ageGroup];
                    const zScore = (totalTime - norm.mean) / norm.sd;
                    const percentile = 100 - zScoreToPercentile(zScore); // Corrigido: menor tempo = maior percentil
                    
                    let classification = 'Médio';
                    if (percentile < 2) classification = 'Muito Baixo';
                    else if (percentile < 16) classification = 'Limítrofe';
                    else if (percentile > 84) classification = 'Superior';
                    else if (percentile > 98) classification = 'Muito Superior';

                    document.getElementById('normative-result').innerHTML = `
                        <p>Para a faixa de <strong>${ageGroup} anos</strong>:</p>
                        <ul>
                            <li>Seu desempenho está no <strong>percentil ${percentile}</strong>.</li>
                            <li>Isso é considerado <strong>${classification}</strong>.</li>
                        </ul>
                        <small>(Média: ${norm.mean.toFixed(2)}s, Desvio Padrão: ${norm.sd.toFixed(2)}s)</small>`;
                });
            }

            showMessage(content, type) {
                this.dom.message.innerHTML = content;
                this.dom.message.className = `message-box message-${type}`;
            }
        }

        document.addEventListener('DOMContentLoaded', () => new TMTTest());
    </script>
</body>
</html>
```
