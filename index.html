<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>TMT-A Web (v2.0) — Trail Making Test A</title>
<meta name="description" content="Implementação web do TMT-A com treino, temporização precisa, layout reprodutível e exportação de dados.">
<style>
:root{
  --bg:#f6f8fb; --fg:#0f172a; --muted:#64748b; --primary:#2563eb; --ok:#16a34a; --warn:#f59e0b; --err:#dc2626;
  --card:#ffffff; --radius:14px; --shadow:0 10px 30px rgba(2,8,23,.08);
  --circle:52px; --min-gap:80px;
}
*{box-sizing:border-box}
html,body{height:100%}
body{margin:0; font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,"Helvetica Neue",Arial,sans-serif; color:var(--fg); background:var(--bg); display:flex; align-items:center; justify-content:center; padding:12px}
button{appearance:none; border:none; border-radius:12px; font-weight:600; cursor:pointer; padding:10px 14px}
.btn{background:var(--primary); color:#fff}
.btn:hover{opacity:.95}
.btn.ghost{background:#e2e8f0; color:#0f172a}
.btn.dark{background:#0f172a; color:#fff}
.btn.ok{background:var(--ok); color:#fff}
.btn.warn{background:var(--warn); color:#fff}
.btn.err{background:var(--err); color:#fff}
#app{width:100%; max-width:980px; background:var(--card); border-radius:var(--radius); box-shadow:var(--shadow); padding:18px 18px 22px}
header{display:flex; align-items:center; justify-content:space-between; gap:10px}
h1{font-size:1.2rem; margin:0; font-weight:800}
.small{font-size:.85rem; color:var(--muted)}
.row{display:flex; flex-wrap:wrap; gap:8px; align-items:center}
.sep{height:1px; background:#eef2f7; margin:12px 0}
label{font-size:.92rem}
input[type="text"],select{
  padding:10px 12px; border:1px solid #e5e7eb; border-radius:10px; min-width:220px; font-size:1rem;
}
.grid{display:grid; gap:10px}
.grid.two{grid-template-columns:1fr 1fr}
@media (max-width:800px){.grid.two{grid-template-columns:1fr}}
.card{border:1px solid #e5e7eb; border-radius:12px; padding:10px}
#boardWrap{position:relative; width:100%; height:min(70vh,640px); min-height:420px; border:1px solid #e5e7eb; border-radius:12px; background:#fff; overflow:hidden}
#board{position:absolute; inset:0}
#trace{position:absolute; inset:0}
.node{
  width:var(--circle); height:var(--circle); position:absolute; display:flex; align-items:center; justify-content:center;
  border-radius:999px; border:3px solid #0f172a; background:#fff; font-weight:800; user-select:none; touch-action:manipulation;
  box-shadow:0 2px 8px rgba(2,8,23,.08); transition:transform .08s ease
}
.node:hover{transform:scale(1.06)}
.node.target{outline:4px solid rgba(37,99,235,.35); border-color:var(--primary)}
.node.correct{background:linear-gradient(135deg,#16a34a,#22c55e); color:#fff; border-color:#16a34a}
.node.err{background:linear-gradient(135deg,#dc2626,#ef4444); color:#fff; border-color:#dc2626}
.info{padding:10px; border:1px solid #dbe2ea; border-radius:10px; background:#f8fafc}
.warn{background:#fffbeb; border-color:#fde68a}
.ok{background:#f0fdf4; border-color:#bbf7d0}
.stat{display:flex; justify-content:space-between; padding:6px 0}
.stat .k{color:var(--muted)}
.stat .v{font-weight:800}
#phases{display:flex; gap:8px; flex-wrap:wrap; margin:6px 0}
.pill{padding:6px 10px; border-radius:999px; background:#e5e7eb; font-weight:700; font-size:.85rem}
.pill.active{background:var(--primary); color:#fff}
.pill.done{background:var(--ok); color:#fff}
.mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace; font-size:.9rem}
.smallmuted{font-size:.85rem; color:var(--muted)}
.controls{display:flex; gap:8px; flex-wrap:wrap}
.progress{height:8px; width:100%; background:#e5e7eb; border-radius:999px; overflow:hidden}
.fill{height:100%; width:0%; background:linear-gradient(90deg,var(--primary),var(--ok)); transition:width .2s ease}
.high-contrast{--primary:#000080; --fg:#000; --card:#fff}
.high-contrast .node{border-width:4px}
</style>
</head>
<body>
<div id="app" role="main" aria-live="polite">
  <header>
    <h1>TMT-A Web <span class="small">v2.0</span></h1>
    <div class="row">
      <button id="helpBtn" class="btn ghost">Ajuda</button>
      <button id="fsBtn" class="btn ghost" title="Tela cheia">Tela cheia</button>
    </div>
  </header>

  <div class="grid two">
    <div class="card">
      <div class="row">
        <div>
          <label for="pid">ID participante</label><br/>
          <input id="pid" type="text" placeholder="ex.: BR-001-A" autocomplete="off">
        </div>
        <div>
          <label for="level">Dificuldade</label><br/>
          <select id="level">
            <option value="std" selected>Padrão (25 nós)</option>
            <option value="tight">Denso (25 nós, gap menor)</option>
            <option value="wide">Espaçado (25 nós, gap maior)</option>
          </select>
        </div>
      </div>
      <div id="phases" class="row">
        <div class="pill" id="p1">Instruções</div>
        <div class="pill" id="p2">Treino</div>
        <div class="pill" id="p3">Teste</div>
        <div class="pill" id="p4">Resultados</div>
      </div>
      <div id="msg" class="info">Você conectará os números de <b>1</b> a <b>25</b> em ordem, o mais rápido possível, sem pular números. Faça primeiro um <b>treino</b>.</div>
      <div class="sep"></div>
      <div class="controls">
        <button id="trainBtn" class="btn dark">Iniciar TREINO</button>
        <button id="startBtn" class="btn ok" disabled>Iniciar TESTE</button>
        <button id="abortBtn" class="btn warn" disabled>Abortar</button>
        <button id="resetBtn" class="btn ghost">Reset</button>
      </div>
      <div class="sep"></div>
      <div class="progress"><div id="fill" class="fill"></div></div>
      <div class="smallmuted">Dica: use <b>tela cheia</b> e mantenha a aba ativa. Pode responder por <b>clique</b> ou <b>Barra de Espaço</b> (com foco no alvo).</div>
    </div>

    <div class="card">
      <div class="stat"><div class="k">Tempo</div><div class="v mono" id="timeLbl">00:00.000</div></div>
      <div class="stat"><div class="k">Próximo número</div><div class="v" id="nextLbl">–</div></div>
      <div class="stat"><div class="k">Erros</div><div class="v" id="errLbl">0</div></div>
      <div class="stat"><div class="k">Comprimento do traço</div><div class="v mono" id="lenLbl">0 px</div></div>
      <div class="stat"><div class="k">Interseções (crossings)</div><div class="v" id="crossLbl">0</div></div>
      <div class="stat"><div class="k">Seed</div><div class="v mono" id="seedLbl">–</div></div>
    </div>
  </div>

  <div class="sep"></div>

  <div id="boardWrap" aria-label="Área do teste">
    <canvas id="trace"></canvas>
    <div id="board"></div>
  </div>

  <div class="sep"></div>

  <div class="grid two">
    <div class="card">
      <div class="row">
        <button id="dlDetail" class="btn">Baixar CSV detalhado</button>
        <button id="dlSummary" class="btn dark">Baixar CSV resumido</button>
        <button id="postBtn" class="btn ghost">Enviar (POST)*</button>
        <button id="contrastBtn" class="btn ghost">Alto Contraste</button>
        <button id="biggerBtn" class="btn ghost">Alvos maiores</button>
      </div>
      <div class="smallmuted">* Configure <span class="mono">POST_ENDPOINT</span> no código para habilitar.</div>
    </div>
    <div class="card">
      <div class="small">Nota clínica / pesquisa:</div>
      <div class="smallmuted">Implementação digital análoga ao TMT-A. Recomenda-se validação local e critérios de QC (tempo mínimo, taxa de erro, crossings) conforme protocolo.</div>
    </div>
  </div>
</div>

<!-- Dialog ajuda -->
<dialog id="dlg">
  <h3>Instruções</h3>
  <p>Conecte os números em ordem (1→25) clicando neles. Faça primeiro o treino (1→5). Evite cliques fora de sequência.</p>
  <p>O traçado é desenhado e interseções são contadas (indicador de desorganização). Ao final, você pode baixar CSV detalhado (ensaio a ensaio) e resumido.</p>
  <div class="row" style="justify-content:flex-end; margin-top:8px">
    <form method="dialog"><button class="btn ghost">Fechar</button></form>
  </div>
</dialog>

<script>
/*** ====== Config geral ====== ***/
const VERSION = "v2.0";
const POST_ENDPOINT = ""; // opcional: URL para envio JSON. Vazio = desativado.
const NODES = 25;         // TMT-A
const TRAIN_N = 5;        // treino mínimo obrigatório
const MINUTES_LIMIT = 5;  // hard timeout de segurança

// Espaçamento e tamanho — adaptáveis por "level"
const LEVELS = {
  std:   { gap: 80,  size: 52 },
  tight: { gap: 70,  size: 48 },
  wide:  { gap: 95,  size: 56 }
};

/*** ====== PRNG e seed a partir do ID ====== ***/
function fnv1aSeed(str){
  let h = 0x811c9dc5;
  for (let i=0;i<str.length;i++){ h ^= str.charCodeAt(i); h = Math.imul(h, 16777619) >>> 0; }
  return h>>>0;
}
function mulberry32(a){ return function(){ let t=a+=0x6D2B79F5; t=Math.imul(t^(t>>>15), t|1); t^=t+Math.imul(t^(t>>>7), t|61); return ((t^(t>>>14))>>>0)/4294967296; } }
function rndRange(r, a, b){ return a + Math.floor(r()*(b-a+1)); }

/*** ====== Utilidades ====== ***/
const $ = s => document.querySelector(s);
function fmtTime(ms){
  const m = Math.floor(ms/60000), s = Math.floor((ms%60000)/1000), u = Math.floor(ms%1000);
  return `${String(m).padStart(2,"0")}:${String(s).padStart(2,"0")}.${String(u).padStart(3,"0")}`;
}
function dist(a,b){ const dx=a.x-b.x, dy=a.y-b.y; return Math.hypot(dx,dy); }
function segIntersect(a,b,c,d){ // interseção de segmentos AB e CD
  const det = (x1,y1,x2,y2,x3,y3,x4,y4)=> (x1-x2)*(y3-y4) - (y1-y2)*(x3-x4);
  const D = det(a.x,a.y,b.x,b.y,c.x,c.y,d.x,d.y);
  if (D === 0) return false;
  const pre = (a.x*b.y - a.y*b.x), post = (c.x*d.y - c.y*d.x);
  const x = (pre*(c.x - d.x) - (a.x - b.x)*post)/D;
  const y = (pre*(c.y - d.y) - (a.y - b.y)*post)/D;
  const within = (x>=Math.min(a.x,b.x)-1e-6 && x<=Math.max(a.x,b.x)+1e-6 &&
                  y>=Math.min(a.y,b.y)-1e-6 && y<=Math.max(a.y,b.y)+1e-6 &&
                  x>=Math.min(c.x,d.x)-1e-6 && x<=Math.max(c.x,d.x)+1e-6 &&
                  y>=Math.min(c.y,d.y)-1e-6 && y<=Math.max(c.y,d.y)+1e-6);
  return within;
}

/*** ====== Áudio (feedback) ====== ***/
let audioCtx = null;
function initAudio(){ if (!audioCtx){ const C = window.AudioContext||window.webkitAudioContext; if (C) audioCtx = new C(); } }
function beep(freq=880,dur=.08){
  if (!audioCtx) return;
  const t0 = audioCtx.currentTime;
  const o = audioCtx.createOscillator(), g = audioCtx.createGain();
  o.type='sine'; o.frequency.value=freq;
  o.connect(g); g.connect(audioCtx.destination);
  g.gain.value=.0001; g.gain.exponentialRampToValueAtTime(.2, t0+.01); g.gain.exponentialRampToValueAtTime(.0001,t0+dur);
  o.start(t0); o.stop(t0+dur);
}

/*** ====== Estado ====== ***/
const State = {
  pid:"", level:"std", seed:0, r:null,
  // dimensões
  W:0, H:0, margin:16,
  // nós e posições
  nodes:[], // [{n,x,y}]
  // execução
  running:false, training:false, start:0, end:0, timer:null, timeout:null,
  next:1, errors:[], clicks:[], // clicks válidos e inválidos
  length:0, crossings:0,
  // desenho
  ctx:null,
  // logs
  detail:[], // eventos
};

/*** ====== DOM elts ====== ***/
const pidEl = $('#pid'), levelEl = $('#level'), timeLbl = $('#timeLbl'), nextLbl = $('#nextLbl');
const errLbl = $('#errLbl'), lenLbl = $('#lenLbl'), crossLbl = $('#crossLbl'), seedLbl = $('#seedLbl');
const trainBtn = $('#trainBtn'), startBtn = $('#startBtn'), abortBtn = $('#abortBtn'), resetBtn = $('#resetBtn');
const boardWrap = $('#boardWrap'), board = $('#board'), trace = $('#trace'), fill = $('#fill');
const helpBtn = $('#helpBtn'), dlg = $('#dlg'), fsBtn = $('#fsBtn'), contrastBtn = $('#contrastBtn'), biggerBtn = $('#biggerBtn');
const dlDetail = $('#dlDetail'), dlSummary = $('#dlSummary'), postBtn = $('#postBtn');
const p1=$('#p1'), p2=$('#p2'), p3=$('#p3'), p4=$('#p4'); const msgEl = $('#msg');

/*** ====== Fases ====== ***/
function phase(i){
  [p1,p2,p3,p4].forEach((p,idx)=>{ p.className = "pill"+(idx<i?" done": idx===i?" active":""); });
}
phase(0);

/*** ====== Fullscreen ====== ***/
async function toggleFS(){
  try{
    if (!document.fullscreenElement) { await document.documentElement.requestFullscreen(); fsBtn.textContent="Sair tela cheia"; }
    else { await document.exitFullscreen(); fsBtn.textContent="Tela cheia"; }
  }catch(e){}
}
document.addEventListener('fullscreenchange',()=>{ fsBtn.textContent = document.fullscreenElement?"Sair tela cheia":"Tela cheia"; });

/*** ====== Layout responsivo ==== ***/
function measure(){
  const r = boardWrap.getBoundingClientRect();
  State.W = Math.floor(r.width); State.H = Math.floor(r.height);
  trace.width = State.W; trace.height = State.H; // canvas
  State.ctx = trace.getContext('2d');
}

/*** ====== Geração de posições (Poisson-like) ====== ***/
function genPositions(){
  const cfg = LEVELS[State.level];
  const R = State.r, gap = cfg.gap, size = cfg.size;
  document.documentElement.style.setProperty('--circle', size+"px");
  document.documentElement.style.setProperty('--min-gap', gap+"px");

  const margin = Math.max(size/2 + 8, State.margin);
  const maxTry = 4000;
  const arr = [];
  let tries = 0;
  while (arr.length < NODES && tries < maxTry){
    const x = margin + R()*(State.W - 2*margin);
    const y = margin + R()*(State.H - 2*margin);
    let ok = true;
    for (const p of arr){ if (dist(p,{x,y}) < gap) { ok=false; break; } }
    if (ok) arr.push({x,y,n:arr.length+1});
    tries++;
  }
  // fallback simples: relaxa gap em 10% se necessário
  while (arr.length < NODES){
    const x = margin + R()*(State.W - 2*margin);
    const y = margin + R()*(State.H - 2*margin);
    let ok = true;
    for (const p of arr){ if (dist(p,{x,y}) < gap*0.9) { ok=false; break; } }
    if (ok) arr.push({x,y,n:arr.length+1});
  }
  State.nodes = arr;
}

/*** ====== Renderização de nós ====== ***/
function clearBoard(){
  board.innerHTML = "";
  State.ctx.clearRect(0,0,State.W,State.H);
  State.length = 0; State.crossings = 0; updateStats();
}
function drawNodes(limit=NODES){
  clearBoard();
  for (let i=0;i<limit;i++){
    const p = State.nodes[i];
    const d = document.createElement('div');
    d.className='node'; d.textContent = p.n;
    d.style.left = (p.x - (parseInt(getComputedStyle(document.documentElement).getPropertyValue('--circle'))/2))+"px";
    d.style.top  = (p.y - (parseInt(getComputedStyle(document.documentElement).getPropertyValue('--circle'))/2))+"px";
    d.dataset.n = p.n;
    d.setAttribute('role','button');
    d.setAttribute('aria-label',`Número ${p.n}`);
    d.tabIndex = (p.n===1?0:-1);
    if (p.n===1) d.classList.add('target');
    d.addEventListener('click', onNodeClick);
    d.addEventListener('keydown', e=>{ if (e.code==='Space' || e.code==='Enter'){ e.preventDefault(); d.click(); } });
    board.appendChild(d);
  }
}

/*** ====== Linhas, comprimento e crossings ====== ***/
function drawSegment(a,b){
  const ctx = State.ctx;
  ctx.lineWidth = 4; ctx.strokeStyle = "#334155";
  ctx.lineCap = "round";
  ctx.beginPath(); ctx.moveTo(a.x,a.y); ctx.lineTo(b.x,b.y); ctx.stroke();
  // comprimento cumulativo
  State.length += dist(a,b);
  // crossings: verificar com segmentos anteriores
  let crossings = 0;
  if (State.clicks.length >= 2){ // temos pelo menos 1 segmento anterior
    const currA = a, currB = b;
    for (let i=1;i<State.clicks.length-1;i++){
      const A = State.nodes[State.clicks[i-1].n-1];
      const B = State.nodes[State.clicks[i].n-1];
      if (!A || !B) continue;
      // ignora adjacências que compartilham vértice
      if (A===currA || A===currB || B===currA || B===currB) continue;
      if (segIntersect(A,B,currA,currB)) crossings++;
    }
  }
  State.crossings += crossings;
}

/*** ====== Execução ====== ***/
function prepare(mode){ // mode: "train" ou "test"
  const id = (pidEl.value||"").trim();
  if (!id){ alert("Informe o ID do participante."); pidEl.focus(); return false; }
  State.pid = id;
  State.level = levelEl.value;
  State.seed = fnv1aSeed(id + "|" + State.level);
  State.r = mulberry32(State.seed);
  seedLbl.textContent = String(State.seed);

  measure();
  genPositions();

  State.training = (mode==="train");
  State.running = false;
  State.next = 1;
  State.errors = [];
  State.clicks = [];
  State.detail = [];
  timeLbl.textContent = "00:00.000";
  nextLbl.textContent = "1";
  errLbl.textContent = "0";
  lenLbl.textContent = "0 px";
  crossLbl.textContent = "0";

  fill.style.width = "0%";
  msgEl.className = "info";
  msgEl.textContent = State.training
    ? "TREINO: conecte 1→5. Aproveite para se familiarizar."
    : "TESTE: conecte 1→25, rápido e com precisão.";

  drawNodes(State.training ? TRAIN_N : NODES);
  phase(State.training ? 1 : 2);
  startBtn.disabled = State.training; // habilita após treino
  abortBtn.disabled = true;
  return true;
}

function startRun(){
  if (!State.nodes.length) return;
  initAudio(); try{ audioCtx && audioCtx.resume && audioCtx.resume(); }catch(e){}
  State.running = true;
  State.start = performance.now();
  State.end = 0;
  abortBtn.disabled = false;

  // timer UI
  State.timer = setInterval(()=>{
    if (!State.running) return;
    const el = performance.now() - State.start;
    timeLbl.textContent = fmtTime(el);
  }, 20);

  // timeout segurança
  State.timeout = setTimeout(()=>{
    if (State.running) finish(true);
  }, MINUTES_LIMIT*60000);

  phase(State.training ? 1 : 2); // permanece na fase corrente
}

function abortRun(){
  if (!State.running) return;
  finish(true);
}

function finish(timeout=false){
  State.running = false;
  State.end = performance.now();
  clearInterval(State.timer); State.timer=null;
  if (State.timeout){ clearTimeout(State.timeout); State.timeout=null; }

  const doneSet = State.training ? (State.next>TRAIN_N) : (State.next> NODES);
  msgEl.className = timeout ? "info warn" : doneSet ? "info ok" : "info";
  msgEl.textContent = timeout
    ? "Teste interrompido por tempo limite."
    : doneSet ? "Etapa concluída. Baixe os CSVs abaixo se desejar."
              : "Etapa finalizada.";

  abortBtn.disabled = true;

  if (State.training){
    // habilita TESTE
    startBtn.disabled = false;
    phase(1);
  }else{
    phase(3);
  }
  updateStats();
}

/*** ====== Lógica de clique ====== ***/
function onNodeClick(e){
  const n = parseInt(e.currentTarget.dataset.n,10);
  const t = performance.now();
  const expected = State.next;

  if (!State.running){ // iniciar automaticamente quando clicar "1"
    if (n!==1) { blinkErr(e.currentTarget, "Aguarde. Comece do 1."); return; }
    startRun();
  }

  State.detail.push({
    type: (n===expected) ? "hit":"error",
    n, expected, t,
  });

  if (n===expected){
    // marca correto
    e.currentTarget.classList.remove('err');
    e.currentTarget.classList.add('correct');
    e.currentTarget.classList.remove('target');
    beep(900,.06);

    // traçado e métricas
    const curr = State.nodes[n-1];
    if (State.clicks.length>0){
      const prevN = State.clicks[State.clicks.length-1].n;
      const prev = State.nodes[prevN-1];
      drawSegment(prev, curr);
    }
    State.clicks.push({n, t});
    State.next++;
    nextLbl.textContent = String(State.training ? Math.min(State.next, TRAIN_N) : Math.min(State.next, NODES));
    updateProgress();

    // destacar novo alvo
    document.querySelectorAll('.node').forEach(d=>{
      const dn = parseInt(d.dataset.n,10);
      d.classList.toggle('target', dn===State.next);
      d.tabIndex = (dn===State.next?0:-1);
    });

    // fim?
    const limit = State.training ? TRAIN_N : NODES;
    if (State.next > limit){ finish(false); }

  }else{
    // erro
    classError(e.currentTarget, n, expected);
  }
}

function classError(el, clicked, expected){
  const type = (clicked < expected) ? "perseveration" // repetição/antecipação
            : (clicked === expected+1) ? "skip_ahead" // pulou 1
            : "sequence"; // fora de sequência

  State.errors.push({t:performance.now(), clicked, expected, type});
  errLbl.textContent = String(State.errors.length);
  blinkErr(el, `Erro (${type}). Clique no ${expected}.`);
  beep(220,.10);
}

function blinkErr(el, msg){
  el.classList.add('err');
  msgEl.className = "info warn";
  msgEl.textContent = msg;
  setTimeout(()=>{ el.classList.remove('err'); msgEl.className="info"; }, 800);
}

/*** ====== UI ====== ***/
function updateStats(){
  const len = Math.round(State.length);
  const crosses = State.crossings;
  lenLbl.textContent = `${len} px`;
  crossLbl.textContent = String(crosses);
}
function updateProgress(){
  const limit = State.training ? TRAIN_N : NODES;
  const p = (Math.min(State.next-1,limit)/limit)*100;
  fill.style.width = p.toFixed(1)+"%";
  updateStats();
}

/*** ====== CSV ====== ***/
function csvRow(arr){
  return arr.map(v=>{
    if (v==null) return "";
    const s = String(v);
    return /[",\n]/.test(s) ? `"${s.replace(/"/g,'""')}"` : s;
  }).join(",")+"\n";
}
function downloadCsv(name, text){
  const blob = new Blob([text], {type:"text/csv;charset=utf-8"});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href=url; a.download=name; document.body.appendChild(a); a.click();
  URL.revokeObjectURL(url); a.remove();
}
function buildSummary(){
  const totalMs = (State.end && State.start)? (State.end - State.start) : 0;
  // ICTs (apenas acertos, consecutivos)
  const ict = [];
  for (let i=1;i<State.clicks.length;i++){ ict.push(State.clicks[i].t - State.clicks[i-1].t); }
  const mean = ict.length? ict.reduce((a,b)=>a+b,0)/ict.length : NaN;
  const sd = ict.length? Math.sqrt(ict.reduce((s,x)=>s+(x-mean)*(x-mean),0)/ict.length) : NaN;

  const meta = {
    version: VERSION,
    tsISO: new Date().toISOString(),
    pid: State.pid,
    seed: State.seed,
    level: State.level,
    ua: navigator.userAgent,
    screen: {w:screen?.width,h:screen?.height,dpr:window.devicePixelRatio||1},
    training: State.training?true:false
  };

  let csv = "# session,"+JSON.stringify(meta)+"\n";
  csv += csvRow(["pid","level","training","completed","total_ms","total_s","hits","errors","trace_len_px","crossings","ict_mean_ms","ict_sd_ms","seed","version"]);
  const completed = State.training ? (State.next>TRAIN_N) : (State.next>NODES);
  csv += csvRow([
    State.pid, State.level, State.training ? 1:0, completed ? 1:0,
    Math.round(totalMs), (totalMs/1000).toFixed(3),
    State.clicks.length, State.errors.length,
    Math.round(State.length), State.crossings,
    isFinite(mean)? mean.toFixed(2):"", isFinite(sd)? sd.toFixed(2):"",
    State.seed, VERSION
  ]);
  return csv;
}
function buildDetail(){
  const meta = {
    version: VERSION,
    tsISO: new Date().toISOString(),
    pid: State.pid, seed: State.seed, level: State.level,
    ua: navigator.userAgent,
    screen: {w:screen?.width,h:screen?.height,dpr:window.devicePixelRatio||1},
    training: State.training?true:false
  };
  let csv = "# session,"+JSON.stringify(meta)+"\n";
  csv += csvRow(["pid","event","n","expected","t_ms_from_start"]);
  for (const ev of State.detail){
    const t0 = State.start || (State.detail.length? State.detail[0].t : 0);
    csv += csvRow([State.pid, ev.type, ev.n, ev.expected, Math.round(ev.t - t0)]);
  }
  // clicks válidos (para reconstrução)
  csv += csvRow([]);
  csv += "# clicks\n";
  csv += csvRow(["idx","n","t_ms_from_start"]);
  for (let i=0;i<State.clicks.length;i++){
    const c = State.clicks[i];
    csv += csvRow([i+1, c.n, Math.round(c.t - State.start)]);
  }
  // erros classificados
  csv += csvRow([]);
  csv += "# errors\n";
  csv += csvRow(["t_ms_from_start","clicked","expected","type"]);
  for (const e of State.errors){
    csv += csvRow([Math.round(e.t - State.start), e.clicked, e.expected, e.type]);
  }
  return csv;
}

/*** ====== POST opcional ====== ***/
async function postPayload(){
  if (!POST_ENDPOINT){ alert("POST_ENDPOINT não configurado."); return; }
  const payload = {
    session: {
      version: VERSION, tsISO: new Date().toISOString(), pid: State.pid, seed: State.seed, level: State.level,
      ua: navigator.userAgent, screen:{w:screen?.width,h:screen?.height,dpr:window.devicePixelRatio||1}, training: State.training
    },
    nodes: State.nodes, clicks: State.clicks, errors: State.errors, detail: State.detail,
    totals: { length: State.length, crossings: State.crossings, elapsed_ms: State.end - State.start }
  };
  try{
    const res = await fetch(POST_ENDPOINT,{method:"POST", headers:{"Content-Type":"application/json"}, body:JSON.stringify(payload)});
    alert(res.ok? "Dados enviados." : "Falha no envio.");
  }catch(e){ alert("Erro: "+e.message); }
}

/*** ====== Acessibilidade extra ====== ***/
let highContrast = false, bigger = false;
function toggleContrast(){ highContrast=!highContrast; document.body.classList.toggle('high-contrast', highContrast); }
function toggleBigger(){
  bigger=!bigger;
  const curr = getComputedStyle(document.documentElement).getPropertyValue('--circle');
  const px = parseInt(curr,10);
  const tgt = bigger? (px+10): (px-10);
  document.documentElement.style.setProperty('--circle', Math.max(40, Math.min(72, tgt))+"px");
  // re-render manter posições, só re-centraliza nós conforme novo tamanho
  drawNodes(State.training ? TRAIN_N : NODES);
}

/*** ====== Eventos ====== ***/
helpBtn.addEventListener('click', ()=>dlg.showModal());
fsBtn.addEventListener('click', toggleFS);
trainBtn.addEventListener('click', ()=> prepare("train") && startRun());
startBtn.addEventListener('click', ()=>{ if (prepare("test")) startRun(); });
abortBtn.addEventListener('click', abortRun);
resetBtn.addEventListener('click', ()=>{ State.nodes=[]; clearBoard(); phase(0);
  pidEl.disabled=false; startBtn.disabled=true; abortBtn.disabled=true;
  msgEl.className="info"; msgEl.textContent="Você conectará os números de 1 a 25 em ordem, o mais rápido possível, sem pular números. Faça primeiro um treino.";
  fill.style.width="0%"; timeLbl.textContent="00:00.000"; nextLbl.textContent="–"; errLbl.textContent="0"; lenLbl.textContent="0 px"; crossLbl.textContent="0"; seedLbl.textContent="–";
});
contrastBtn.addEventListener('click', toggleContrast);
biggerBtn.addEventListener('click', toggleBigger);

dlSummary.addEventListener('click', ()=>{
  if (!State.end){ alert("Finalize uma etapa para baixar o resumo."); return; }
  downloadCsv(`tmta_summary_${State.pid||"anon"}.csv`, buildSummary());
});
dlDetail.addEventListener('click', ()=>{
  if (!State.detail.length){ alert("Sem eventos registrados ainda."); return; }
  downloadCsv(`tmta_detail_${State.pid||"anon"}.csv`, buildDetail());
});
postBtn.addEventListener('click', postPayload);

// teclado global
document.addEventListener('keydown', (e)=>{
  if (e.code==='Space'){
    const tgt = document.querySelector('.node.target');
    if (tgt) { e.preventDefault(); tgt.click(); }
  }
  if (e.code==='Escape'){ abortRun(); }
});

// resize / orientation
window.addEventListener('resize', ()=>{
  if (!State.nodes.length) return;
  // re-medida e re-desenho mantendo mesma distribuição relativa (fixo em px do viewport atual)
  measure();
  drawNodes(State.training ? TRAIN_N : NODES);
});
window.addEventListener('orientationchange', ()=> setTimeout(()=>window.dispatchEvent(new Event('resize')),300));

/*** ====== Boot ====== ***/
measure();
msgEl.textContent = "Você conectará os números de 1 a 25 em ordem, o mais rápido possível, sem pular números. Faça primeiro um treino (1→5).";
startBtn.disabled = true; // só habilita após treino concluído
phase(0);
</script>
</body>
</html>
